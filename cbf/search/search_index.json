{"config":{"lang":["en","zh"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cosmic Binary Format","text":""},{"location":"#configuring-maven-gradle","title":"Configuring Maven / Gradle","text":"<p>CBF is xenondevs' lazy evaluation binary format used primarily in Nova. To use CBF, you first have to add the xenondevs maven repository to your build configuration.</p> MavenGradle GroovyGradle Kotlin <pre><code>&lt;repository&gt;\n    &lt;id&gt;xenondevs&lt;/id&gt;\n    &lt;url&gt;https://repo.xenondevs.xyz/releases&lt;/url&gt;\n&lt;/repository&gt;\n</code></pre> <pre><code>maven {\n    url 'https://repo.xenondevs.xyz/releases'\n}\n</code></pre> <pre><code>maven {\n    url = uri(\"https://repo.xenondevs.xyz/releases\")\n}\n</code></pre> <p>Now you can add CBF to your build configuration:</p> MavenGradle GroovyGradle Kotlin <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;xyz.xenondevs.cbf&lt;/groupId&gt;\n    &lt;artifactId&gt;cosmic-binary-format&lt;/artifactId&gt;\n    &lt;version&gt;0.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>implementation \"xyz.xenondevs.cbf:cosmic-binary-format:0.1\"\n</code></pre> <pre><code>implementation(\"xyz.xenondevs.cbf:cosmic-binary-format:0.1\")\n</code></pre> <p>To get started, you also need to install a CBF adapter. Currently, only the netty adapter is available.</p> MavenGradle GroovyGradle Kotlin <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;xyz.xenondevs.cbf&lt;/groupId&gt;\n    &lt;artifactId&gt;cosmic-binary-format-netty-adapter&lt;/artifactId&gt;\n    &lt;version&gt;0.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>implementation \"xyz.xenondevs.cbf:cosmic-binary-format-netty-adapter:0.1\"\n</code></pre> <pre><code>implementation(\"xyz.xenondevs.cbf:cosmic-binary-format-netty-adapter:0.1\")\n</code></pre> <p>You can then set the <code>defaultBufferProvider</code> to Netty:</p> <pre><code>CBF.defaultBufferProvider = NettyBufferProvider\n</code></pre>"},{"location":"binaryadapter/","title":"BinaryAdapters","text":"<p>Binary adapters are used to serialize and deserialize objects into binary data.</p> Default adapters <p>The following adapters are available by default:</p> <ul> <li>Byte</li> <li>ByteArray</li> <li>Short</li> <li>ShortArray</li> <li>Int</li> <li>IntArray</li> <li>Long</li> <li>LongArray</li> <li>Float</li> <li>FloatArray</li> <li>Double</li> <li>DoubleArray</li> <li>Boolean</li> <li>BooleanArray</li> <li>Char</li> <li>CharArray</li> <li>String</li> <li>StringArray</li> <li>Enum</li> <li>UUID</li> <li>Pair</li> <li>Triple</li> <li>Map</li> <li>Collection</li> <li>Compound</li> </ul>"},{"location":"binaryadapter/#creating-your-own-adapter","title":"Creating your own adapter","text":"<p>Creating your own adapter is easy. You just need to implement the <code>BinaryAdapter</code> interface and register it via the <code>CBF.registerBinaryAdapter</code> function. If you also want subclasses of a type to be serialized, you can use the <code>CBF.registerBinaryHierarchyAdapter</code> function. (For example, the Collection adapter)</p> <p>Let's create a simple adapter that serializes and deserializes a <code>java.awt.Color</code> instance.</p> ColorAdapter<pre><code>object ColorBinaryAdapter : BinaryAdapter&lt;Color&gt; {\n\n    override fun read(type: Type, buf: ByteBuffer): Color {\n        return Color(buf.readInt(), true)\n    }\n\n    override fun write(obj: Color, buf: ByteBuffer) {\n        buf.writeInt(obj.rgb)\n    }\n\n}\n</code></pre> <p>and register it:</p> <pre><code>CBF.registerBinaryAdapter(Color::class, ColorBinaryAdapter)\n</code></pre> <p>If you have generic types, you can use the type parameter.</p> PairBinaryAdapter<pre><code>object PairBinaryAdapter : BinaryAdapter&lt;Pair&lt;*, *&gt;&gt; {\n\n    override fun write(obj: Pair&lt;*, *&gt;, buf: ByteBuffer) {\n        CBF.write(obj.first, buf)\n        CBF.write(obj.second, buf)\n    }\n\n    override fun read(type: Type, buf: ByteBuffer): Pair&lt;*, *&gt; {\n        val typeArguments = (type as ParameterizedType).actualTypeArguments\n\n        return Pair&lt;Any?, Any?&gt;(\n            CBF.read(typeArguments[0], buf),\n            CBF.read(typeArguments[1], buf)\n        )\n    }\n\n}\n</code></pre> <p>The registration works the same way:</p> <pre><code>CBF.registerBinaryAdapter(Pair::class, PairBinaryAdapter)\n</code></pre> <p>Note</p> <p>Both these adapters are already registered by default. Replacing them might cause issues with already serialized data.</p>"},{"location":"compound/","title":"Compound","text":"<p>Compounds allow you store a lot of data in a single object. This makes it easier to get desired data on demand instead of continuously reading from a byte stream. You can pretty much see compounds as maps or json objects. Similar to json, data in compounds can be nested and is deserialized lazily. This means that until you specifically request a value, it will be stored as a byte array (It will of course be cached after the first time it is requested). Let's create a compound:</p> <pre><code>val compound = Compound()\ncompound[\"test1\"] = 123\ncompound[\"test2\"] = \"test\"\ncompound[\"test3\"] = true\ncompound[\"test4\"] = mapOf(\"test\" to 123, \"test2\" to 321)\ncompound[\"test5\"] = Compound().apply { this[\"list\"] = listOf(123, 321) }\n</code></pre> <p>This will create a compound with the following data:</p> <pre><code>{\n    \"test1\": 123\n    \"test2\": test\n    \"test3\": true\n    \"test4\": {test=123, test2=321}\n    \"test5\": {\n        \"list\": [123, 321]\n    }\n}\n</code></pre> <p>We can serialize it the same way we serialize any other object:</p> <pre><code>val bytes = CBF.write(compound)\n</code></pre> <p>We can then deserialize it, and get back the same data:</p> <pre><code>val compound = CBF.read&lt;Compound&gt;(bytes)!!\nprintln(compound.get&lt;Int&gt;(\"test1\")) // prints 123\nprintln(compound.get&lt;String&gt;(\"test2\")) // prints test\nprintln(compound.get&lt;Boolean&gt;(\"test3\")) // prints true\nprintln(compound.get&lt;Map&lt;String, Int&gt;&gt;(\"test4\")) // prints {test=123, test2=321}\nprintln(compound.get&lt;Compound&gt;(\"test5\")!!.get&lt;List&lt;Int&gt;&gt;(\"list\")) // prints [123, 321]\n</code></pre>"},{"location":"instancecreator/","title":"InstanceCreators","text":"<p>Some serializable classes can't be initiated via an empty constructor. This is where <code>InstanceCreators</code> come in. For example, an <code>EnumMap</code> needs the enum class as a constructor parameter. So we can use the <code>Type</code> parameter retrieved  when calling a serialization function to pass the enum class.</p> EnumMapInstanceCreator<pre><code>object EnumMapInstanceCreator : InstanceCreator&lt;EnumMap&lt;*, *&gt;&gt; {\n\n    private val ENUM_MAP_CONSTRUCTOR = EnumMap::class.java.getConstructor(Class::class.java)\n\n    override fun createInstance(type: Type): EnumMap&lt;*, *&gt; {\n        return ENUM_MAP_CONSTRUCTOR.newInstance((type as ParameterizedType).actualTypeArguments[0] as Class&lt;*&gt;)\n    }\n\n}\n</code></pre> <p>You can register it similarly to <code>BinaryAdapters</code>.</p> <pre><code>registerInstanceCreator(EnumMap::class, EnumMapInstanceCreator)\n</code></pre> <p>Note</p> <p>This instance creator is registered by default.</p>"},{"location":"serialization/","title":"Serialization","text":"<p>To actually (de)serialize data, you need to use the CBF singleton.</p>"},{"location":"serialization/#serialization_1","title":"Serialization","text":"<p>To serialize data, you can use the <code>write</code> functions. You can either directly pass a <code>ByteBuffer</code> instance, or automatically  let the previously set <code>defaultBufferProvider</code> provide one and get the bytes directly.</p> <pre><code>val buf = CBF.buffer() // Also uses the default buffer provider\nval list = listOf(\"test1\", \"test2\", \"test3\")\nCBF.write(list, buf)\nval bytes = buf.toByteArray()\n</code></pre> <p>or</p> <pre><code>val list = listOf(\"test1\", \"test2\", \"test3\")\nval bytes = CBF.write(list)\n// ...\n</code></pre>"},{"location":"serialization/#deserialization","title":"Deserialization","text":"<p>Deserialization is pretty similar, but you obviously need to pass input data here. Both <code>ByteBuffer</code> and <code>ByteArray</code> are supported.</p> <pre><code>val list = CBF.read&lt;List&lt;String&gt;&gt;(buffer)\n</code></pre> <p>or</p> <pre><code>val list = CBF.read&lt;List&lt;String&gt;&gt;(bytes)\n</code></pre> <p>Check out the <code>Compound</code> section to see how to store related data in a single object.</p> <p>Tip</p> <p>The <code>NettyBufferProvider</code> also registers a few extension functions allowing you to directly pass a netty <code>ByteBuf</code> instead of the cbf buffer. You can also get a cbf buffer via Netty's <code>ByteBufAllocator</code>. Just call <code>ByteBufAllocator.cbfBuffer()</code>.</p>"}]}